#!/usr/bin/env python3
"""
Copyright 2019 Ronald J. Nowling

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""


import argparse
from collections import defaultdict
import os
import sys
import warnings

import numpy as np

from scipy.stats import chi2
from scipy.stats import chisquare

from sklearn.linear_model import SGDClassifier
from sklearn.metrics import accuracy_score
from sklearn.metrics import balanced_accuracy_score
from sklearn.metrics import confusion_matrix
from sklearn.metrics import log_loss
from sklearn.preprocessing import OneHotEncoder
from sklearn.preprocessing import LabelEncoder

import matplotlib
matplotlib.use("PDF")
import matplotlib.pyplot as plt
import seaborn as sns

from asaph.ml import estimate_lr_iter
from asaph.ml import likelihood_ratio_test

def read_pca_coordinates(flname):
    sample_coordinates = []
    sample_names = []
    with open(flname) as fl:
        # skip header
        next(fl)
        for ln in fl:
            cols = ln.split("\t")

            sample_name = cols[0]
            coordinates = list(map(float, cols[1:]))
            
            sample_names.append(sample_name)
            sample_coordinates.append(coordinates)

    return sample_names, np.array(sample_coordinates)

def read_labels(flname):
    sample_indices = dict()

    with open(flname) as fl:
        for label_idx, ln in enumerate(fl):
            cols = ln.strip().split(",")

            label = cols[0]

            for sample_name in cols[1:]:
                sample_indices[sample_name] = label_idx

    return sample_indices

def read_label_names(flname):
    sample_indices = dict()

    with open(flname) as fl:
        for label_idx, ln in enumerate(fl):
            cols = ln.strip().split(",")

            label = cols[0]

            for sample_name in cols[1:]:
                sample_indices[sample_name] = label

    return sample_indices

def pairwise(iterable):
    iterable = iter(iterable)
    try:
        while True:
            a = next(iterable)
            b = next(iterable)
            yield a, b
    except StopIteration:
        pass
    
def plot_projections(coordinates, pairs, dirname, sample_names, labels=None):
    if len(pairs) % 2 != 0:
        print("Error: PCs must be provided in pairs of 2")
        sys.exit(1)

    if not os.path.exists(dirname):
        os.makedirs(dirname)

    for p1, p2 in pairwise(pairs):
        fig_flname = os.path.join(dirname,
                                  "pca_projection_%s_%s.png" % (str(p1), str(p2)))
        plt.clf()
        fig = plt.gcf()
        fig.set_dpi(150)

        if labels is None:        
            plt.scatter(coordinates[:, p1 - 1],
                        coordinates[:, p2 - 1])
        else:
            label_samples = defaultdict(list)
            for sample_name, label_name in labels.items():
                sample_idx = sample_names.index(sample_name)
                label_samples[label_name].append(sample_idx)

            for i, (label, samples) in enumerate(label_samples.items()):
                plt.scatter(coordinates[samples, p1 - 1],
                            coordinates[samples, p2 - 1],
                            label=label)
                plt.legend()

        plt.xlabel("Component %s" % p1, fontsize=16)
        plt.ylabel("Component %s" % p2, fontsize=16)
        plt.savefig(fig_flname)

def create_class_labels(sample_names, sample_labels):
    str_labels = [sample_labels[name] for name in sample_names]

    encoder = LabelEncoder()
    labels = encoder.fit_transform(str_labels)

    return labels, encoder.classes_
    

def test_labels(coordinates, sample_names, sample_labels):
    class_labels, class_names = create_class_labels(sample_names, sample_labels)

    n_iter = estimate_lr_iter(len(coordinates))
    # we set the intercept to the class ratios in the lr test function
    lr = SGDClassifier(penalty="l2",
                       loss="log",
                       max_iter = n_iter * 10.,
                       tol=1e-8,
                       fit_intercept=True)

    with warnings.catch_warnings():
        warnings.simplefilter("ignore")
        for i in range(coordinates.shape[1]):
            features = coordinates[:, i].reshape(-1, 1)
        
            p_value = likelihood_ratio_test(features,
                                            class_labels,
                                            lr,
                                            set_intercept=False)

            lr.fit(features, class_labels)
            pred_labels = lr.predict(features)
            acc = 100. * accuracy_score(class_labels,
                                        pred_labels)

            bal_acc = 100. * balanced_accuracy_score(class_labels,
                                                     pred_labels)

            cm = confusion_matrix(class_labels,
                                  pred_labels)

            print("Component:", (i+1))
            print("p-value: ", p_value)
            print("Accuracy:", acc)
            print("Balanced accuracy:", bal_acc)
            print(cm)
            print()

        p_value = likelihood_ratio_test(coordinates,
                                        class_labels,
                                        lr,
                                        set_intercept=False)

        lr.fit(coordinates, class_labels)
        pred_labels = lr.predict(coordinates)
        acc = 100. * accuracy_score(class_labels,
                                        pred_labels)

        bal_acc = 100. * balanced_accuracy_score(class_labels,
                                                 pred_labels)

        cm = confusion_matrix(class_labels,
                              pred_labels)

        print("Component:", "all")
        print("p-value: ", p_value)
        print("Accuracy:", acc)
        print("Balanced accuracy:", bal_acc)
        print(cm)
        print()

            

def parseargs():
    parser = argparse.ArgumentParser()

    parser.add_argument("--coordinates",
                        type=str,
                        required=True)

    subparsers = parser.add_subparsers(dest="mode", required=True)

    plot_parser = subparsers.add_parser("plot-projections",
                                        help="Plot PCA projections")
    
    plot_parser.add_argument("--plot-dir",
                             type=str,
                             required=True)

    plot_parser.add_argument("--pairs",
                             nargs="+",
                             type=int,
                             required=True)

    plot_parser.add_argument("--labels-fl",
                             type=str,
                             help="Labels file to use in coloring points")

    label_test_parser = subparsers.add_parser("test-labels",
                                              help="Run association tests on PCs vs labels")

    label_test_parser.add_argument("--labels-fl",
                                   type=str,
                                   required=True,
                                   help="Labels file")
    
    return parser.parse_args()

if __name__ == "__main__":
    args = parseargs()

    if not os.path.exists(args.coordinates):
        print("Coordinates file path is invalid")
        sys.exit(1)

    sample_names, coordinates = read_pca_coordinates(args.coordinates)

    print(coordinates.shape)

    if args.mode == "plot-projections":
        labels = None
        if args.labels_fl:
            labels = read_label_names(args.labels_fl)
        plot_projections(coordinates,
                         args.pairs,
                         args.plot_dir,
                         sample_names,
                         labels=labels)

    elif args.mode == "test-labels":
        labels = read_labels(args.labels_fl)
        test_labels(coordinates,
                    sample_names,
                    labels)
        
    else:
        print("Unknown mode '%s'" % args.mode)
        sys.exit(1)
