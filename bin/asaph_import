#!/usr/bin/env python3

"""
Copyright 2015 Ronald J. Nowling

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""

import argparse
from collections import defaultdict
import os
import sys

import numpy as np
from sklearn.random_projection import johnson_lindenstrauss_min_dim as jl_min_dim

from asaph.feature_matrix_construction import construct_feature_matrix
from asaph.feature_matrix_construction import COUNTS_FEATURE_TYPE
from asaph.feature_matrix_construction import CATEGORIES_FEATURE_TYPE
from asaph.feature_matrix_construction import HASHED_FEATURE_TYPE
from asaph.models import ProjectSummary
from asaph.newioutils import FEATURE_MATRIX_FLNAME
from asaph.newioutils import PROJECT_SUMMARY_FLNAME
from asaph.newioutils import SAMPLE_LABELS_FLNAME
from asaph.newioutils import serialize
from asaph.vcf import stream_vcf_variants

def import_vcf(args):
    if not os.path.exists(args.workdir):
        os.makedirs(args.workdir)

    if args.vcf is not None:
        flname = args.vcf
        gzipped = False
    else:
        flname = args.vcf_gz
        gzipped = True

    variant_stream, individual_names = stream_vcf_variants(flname,
                                                           gzipped,
                                                           args.allele_min_freq_threshold)
    n_samples = len(individual_names)
    if args.num_dimensions is None and args.min_inversion_fraction is None:
        n_dim = jl_min_dim(n_samples, eps=0.1)
    elif args.min_inversion_fraction is not None:
        if not (0.0 < args.min_inversion_fraction < 1.0):
            raise Exception("Minimum inversion fraction must be a number between 0 and 1 (exclusive).")
        n_dim = jl_min_dim(n_samples, eps=args.min_inversion_fraction)
    elif args.num_dimensions is not None:
        n_dim = args.num_dimensions

    feature_matrix = construct_feature_matrix(variant_stream,
                                              n_samples,
                                              args.feature_type,
                                              args.subsampling_method,
                                              args.chunk_size,
                                              n_dim,
                                              n_inner_dim=args.inner_dim)

    print(feature_matrix.shape[0], "individuals")
    print(feature_matrix.shape[1], "features")

    project_summary = ProjectSummary(original_positions = None,
                                     filtered_positions = None,
                                     n_features = feature_matrix.shape[1],
                                     n_samples = feature_matrix.shape[0],
                                     feature_type = args.feature_type,
                                     subsampling_method = args.subsampling_method,
                                     sample_names = individual_names)

    np.savez_compressed(os.path.join(args.workdir, FEATURE_MATRIX_FLNAME + ".npz"),
                        feature_matrix = feature_matrix)
    serialize(os.path.join(args.workdir, SAMPLE_LABELS_FLNAME), individual_names)
    serialize(os.path.join(args.workdir, PROJECT_SUMMARY_FLNAME), project_summary)

def parseargs():
    parser = argparse.ArgumentParser(description="Asaph")

    parser.add_argument("--feature-type",
                        type=str,
                        default="hashed",
                        choices=["counts",
                                 "categories",
                                 "hashed"])

    parser.add_argument("--subsampling-method",
                        type=str,
                        default=None,
                        choices=["random-projection",
                                 "reservoir"])

    parser.add_argument("--chunk-size",
                        type=int,
                        default=10000)

    dimensions_group = parser.add_mutually_exclusive_group()
    dimensions_group.add_argument("--num-dimensions",
                                  type=int,
                                  default=None,
                                  help="Set number of dimensions to use for reduced space." )

    dimensions_group.add_argument("--min-inversion-fraction",
                                  type=float,
                                  help="Use minimum inversion size (in terms of fraction of SNPs) to estimate number of dimensions needed.")

    parser.add_argument("--inner-dim",
                        type=int,
                        default=2**20,
                        help="Number of hashed features to use as an inner dimension with random projection.")
    
    format_group = parser.add_mutually_exclusive_group(required=True)
    format_group.add_argument("--vcf", type=str, help="VCF file to import")
    format_group.add_argument("--vcf-gz", type=str, help="Gzipped VCF file to import")

    parser.add_argument("--selected-samples",
                        type=str,
                        help="Use only these samples")

    parser.add_argument("--workdir",
                        type=str,
                        help="Work directory",
                        required=True)

    parser.add_argument("--allele-min-freq-threshold",
                        type=float,
                        help="Minimum allele frequency allowed",
                        default=0.000001)

    return parser.parse_args()

if __name__ == "__main__":
    args = parseargs()

    import_vcf(args)
